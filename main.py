import os
import sys
import shutil
import pathlib
import time
from datetime import date
from datetime import datetime

#Configuration------------------------------------------------------------------------------------------------------#
#Note - use the forward slash (/) for directories, not the backward slash (\) to avoid errors.
#These are the directories that will be backed up:
user_directories = [
       "C:/Users/darcy/OneDrive/Desktop"
    ]

#This is where the output archives are saved
output_directory = "C:/Users/darcy/ownCloud - Darcy@******.***************.com.au/Automated Backups" 

#you can safely leave the following as is:
data_directory = "./data/"
copy_temp_folder = "./temp/copytemp/"
zip_temp_folder = "./temp/ziptemp/"
data_file_extension = ".log"
data_file_name = "backup-data"
backup_descriptor_filename_and_ext = "backup.txt"

#text-templates
bd_intro_text = "This file was auto-generated by Darcy's icremental(ish) Python based backup software.\nBelow is a list of the directories checked during the backup process.\n"
#-------------------------------------------------------------------------------------------------------------------#

progress_log = 0
CURSOR_UP_ONE = '\x1b[1A' 
ERASE_LINE = '\x1b[2K'  

def initialize():
    #create required directories if non-existent
    if os.path.exists(output_directory) == False:
        os.makedirs(output_directory)
    if os.path.exists(data_directory) == False:
        os.makedirs(data_directory)

    #clear temp directories and then create them again
    if os.path.exists(copy_temp_folder) == True:
        shutil.rmtree(copy_temp_folder)
    os.makedirs(copy_temp_folder)
    if os.path.exists(zip_temp_folder) == True:
        shutil.rmtree(zip_temp_folder)
    os.makedirs(zip_temp_folder)

    #check for initial backup file
    data_file_path = data_directory + "/" + data_file_name + data_file_extension
    if os.path.isfile(data_file_path) == False:
        print("An initial backup was not found. Creating an initial backup now...")
        initial_backup()
    else:
        print("An initial backup was found. Starting an incremental backup...")
        incremental_backup()

def initial_backup():
    #1.1 Get all the files in the user directories that are to be backed up.
    print("Getting all files in the user directories that are to be backed up...")
    all_files = {}
    failed_files = []
    #p_total = 0
    #p_current = 0
    #print("\n")

    print("Starting archive process...")
    for backup_directory in user_directories:
        pathlib_directory = pathlib.Path(backup_directory)
        p_total = len(list(pathlib_directory.rglob("*"))) * len(list(user_directories))
        for file in pathlib_directory.rglob("*"):
            file = str(file).replace("\\", "/")
            if os.path.isfile(file) is True:
                file_mtime = os.path.getmtime(file)
                all_files[file] = file_mtime
            #p_current = p_current + 1
            #print_progress(p_current, p_total)
        #1.2 Create individual archives of user folders
        archive_name = os.path.basename(backup_directory)
        archive_path = zip_temp_folder + "/" + archive_name
        print("Zipping " + archive_name + "...")
        shutil.make_archive(archive_path, "zip", backup_directory)

    #2.1 Create a data file
    print("Creating backup data file...")
    data_file_path = data_directory + "/" + data_file_name + data_file_extension
    if os.path.exists(data_file_path) == True:
        os.remove(data_file_path) #remove data file if it already exists
    data_file = open(data_file_path, "a") #append
    for file, timestamp in all_files.items():
        try:
            data_file.write(file + "|" + str(timestamp) + "\n")
        except:
            failed_files.append(file)
    data_file.close()   

    #create backup descriptor file
    print("Creating backup descriptor file...")
    bd_file = open(zip_temp_folder + "/" + backup_descriptor_filename_and_ext, "w")
    bd_content = "Backup Type: Initial" + "\nBackup Datetime: " + datetime.now().strftime("%d-%m-%Y %H.%M.%S") + "\n\n" + bd_intro_text
    for directory in user_directories:
        bd_content = bd_content + "\n" + directory
    bd_file.write(bd_content)
    bd_file.close()

    #make main archive
    print("Creating main archive from individual archives...")
    archive_name = "Initial Backup - " + datetime.now().strftime("%d-%m-%Y %H.%M.%S")
    shutil.make_archive(output_directory + "/" + archive_name, "zip", zip_temp_folder)
    
    #clear temp
    print("Clearing temp files...")
    shutil.rmtree(copy_temp_folder)
    shutil.rmtree(zip_temp_folder)

    if len(list(failed_files)) == 0:
        print("Completed!")
    else:
        print("Completed with errors occuring for the following file(s):")
        for error_file in failed_files:
            print(error_file)
        print("If the file name or any directory contains a non ascii character, that could be why.")


def incremental_backup():
    #check for initial backup file
    data_file_path = data_directory + "/" + data_file_name + data_file_extension
    if os.path.isfile(data_file_path) == False:
        print("An initial backup was not found. Cannot continue.")
        return

    print("Reading data file to find all previously backed up files...")
    #get all old files from data file
    old_files = {}
    data_file = open(data_file_path, "r") #read only
    data_file_content = data_file.readlines()
    for line in data_file_content:
        line_content = line.strip().split("|")
        file = line_content[0]
        timestamp = line_content[1]
        old_files[file] = timestamp
    data_file.close()

    print("Getting all files in the user directories that are to be backed up...")
    #get all new/modified files from the user directories
    new_files = {}
    failed_files = []

    for backup_directory in user_directories:
        pathlib_directory = pathlib.Path(backup_directory)
        for file in pathlib_directory.rglob("*"):
            file = str(file).replace("\\", "/")
            if os.path.isfile(file) is True:
                file_mtime = os.path.getmtime(file)
                if file not in old_files:
                    #new file!
                    new_files[file] = file_mtime
                else:
                    if file_mtime > float(old_files[file]):
                        #modified file!
                        new_files[file] = file_mtime
                        #remove from old files as its old
                        old_files.pop(file)
    
    print("Copying new and modified files to a temporary directory...")
    directories_in_use = []
    #copy all new files to copy temp
    for file, timestamp in new_files.items():
        file_path_after_user_directory = ""
        for directory in user_directories:
            if directory in file:
                file_path_after_user_directory = os.path.dirname(file).replace(os.path.dirname(directory), "")
        file_destination = copy_temp_folder + "/" + file_path_after_user_directory + "/"
        if os.path.exists(file_destination) == False:
            os.makedirs(file_destination)
        shutil.copy(file, file_destination)

        #make array of directories which have changes for the next archive process
        directory_in_use = os.path.dirname(file_path_after_user_directory).split('/')[1]
        if ((directory_in_use in directories_in_use) == False) and (directory_in_use != "/"):
            directories_in_use.append(directory_in_use)
    
    print("Starting archive process...")
    #archive all copied user directory folders
    for directory in directories_in_use:
        folder = copy_temp_folder + "/" + directory
        individual_output_directory = zip_temp_folder + "/" + directory
        if len(os.listdir(folder)) != 0: #if folder is not empty, then archive it
           print("Zipping " + directory + "...")
           shutil.make_archive(individual_output_directory, "zip", folder)

    #create backup descriptor file
    print("Creating backup descriptor file...")
    bd_file = open(zip_temp_folder + "/" + backup_descriptor_filename_and_ext, "w")
    bd_content = "Backup Type: Incremental" + "\nBackup Datetime: " + datetime.now().strftime("%d-%m-%Y %H.%M.%S") + "\n\n" + bd_intro_text
    for directory in user_directories:
        bd_content = bd_content + "\n" + directory
    bd_content = bd_content + "\n\nNote that as this is an incremental backup, only the new or modified files in the above directories were backed up."
    bd_file.write(bd_content)
    bd_file.close()
    
    #make main archive
    print("Creating main archive from individual archives...")
    archive_name = "Incremental Backup - " + datetime.now().strftime("%d-%m-%Y %H.%M.%S")
    shutil.make_archive(output_directory + "/" + archive_name, "zip", zip_temp_folder)
    
    #clear temp
    print("Clearing temp files...")
    shutil.rmtree(copy_temp_folder)
    shutil.rmtree(zip_temp_folder)

    #create data file
    print("Creating backup data file...")
    data_file_path = data_directory + "/" + data_file_name + data_file_extension
    if os.path.exists(data_file_path) == True:
        os.remove(data_file_path) #remove data file if it already exists
    data_file = open(data_file_path, "a") #append
    try:
        for file, timestamp in new_files.items():
            data_file.write(file + "|" + str(timestamp) + "\n")
        for file, timestamp in old_files.items():
            data_file.write(file + "|" + str(timestamp) + "\n")
    except:
        failed_files.append(file)
    data_file.close()   

    #completed
    if len(list(failed_files)) == 0:
        print("Completed!")
    else:
        print("Completed with errors occuring for the following file(s):")
        for error_file in failed_files:
            print(error_file)
        print("If the file name or any directory contains a non ascii character, that could be why.")


def print_progress(amount, total):
    #was testing this as an idea but is unfinished.
    global progress_log  
    boxes = 32
    empt_char = '▢'
    fill_char = '▣'
    progress = int((amount/total) * 100)
    if progress > progress_log:
        progress_boxes = int((progress/100) * boxes)
        progress_string = (fill_char*(progress_boxes+1)) + (empt_char*(32-progress_boxes-1))
        sys.stdout.write(CURSOR_UP_ONE) 
        sys.stdout.write(ERASE_LINE)
        print("Progress: " + progress_string + " " + str(progress+1) + "%")
    progress_log = progress


initialize()
